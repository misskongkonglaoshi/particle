# Mg颗粒燃烧仿真模型123456

## 项目概述

本项目实现了Mg颗粒在CO2环境中的加热、熔融和反应过程的仿真模拟。模型采用分阶段求解策略，使用MATLAB内置的ODE求解器，避免复杂的自定义数值计算方法。

整个过程分为以下几个阶段：

1. **预热阶段**（T < 923K）：颗粒温度低于熔点，只有温度随时间变化，热量来源于辐射和对流换热。
2. **熔融阶段**（T = 923K）：颗粒达到熔点，温度保持不变，定义熔融百分数，所有热量用于内部金属Mg的熔化。
3. **加热阶段**（923K < T < 1366K）：熔融完成后，温度继续上升，直到达到沸点。
4. **气相燃烧阶段**（T ≥ 1366K）：颗粒达到沸点，发生气相燃烧（框架代码，留待后续实现）。

## 文件结构

```
Mg-CO2/
├── main.m                 # 主程序入口
├── Parameters.m           # 参数定义类
├── ParticleModel.m        # 颗粒物理模型类
├── HeatTransfer.m         # 热传递计算类
├── PreheatingStage.m      # 预热阶段求解器
├── MeltingStage.m         # 熔融阶段求解器
├── HeatingStage.m         # 熔融后加热阶段求解器
├── VaporizationStage.m    # 气相燃烧阶段求解器框架
├── StageManager.m         # 阶段管理器
├── Visualization.m        # 结果可视化
├── README.md              # 项目说明文档
└── results/               # 结果输出目录
    ├── simulation_results.mat  # MATLAB格式结果
    └── simulation_results.csv  # CSV格式结果
```

## 模块功能说明

### 1. 主程序 (`main.m`)

主程序入口，负责初始化参数、创建模型、运行仿真和可视化结果。

主要功能：
- 初始化参数
- 创建物理模型
- 创建阶段管理器
- 运行仿真
- 可视化和保存结果
- 输出仿真信息

### 2. 参数定义 (`Parameters.m`)

定义所有仿真参数的类，包括物理常数、材料属性、环境参数和仿真控制参数。

主要属性：
- 物理常数（气体常数、Stefan-Boltzmann常数等）
- 材料物理参数（Mg、MgO、C的密度、比热容等）
- 颗粒物理参数（初始直径、初始温度）
- 环境参数（环境温度、压力、发射率）
- 气体组成
- 仿真控制参数（时间步长、总时间）
- 求解器配置

主要方法：
- `Parameters()`: 构造函数
- `validate()`: 验证参数的有效性

### 3. 颗粒物理模型 (`ParticleModel.m`)

管理颗粒的物理状态和属性的类。

主要属性：
- 参数对象
- 热传递模型
- 颗粒状态（温度、直径、质量、熔融分数）

主要方法：
- `ParticleModel(params)`: 构造函数
- `calculateMass()`: 计算颗粒质量
- `determineStage()`: 确定当前阶段
- `calculateHeatCapacity()`: 计算颗粒的热容
- `calculateMeltingEnergy()`: 计算完全熔化所需的能量

### 4. 热传递计算 (`HeatTransfer.m`)

处理颗粒的热传递计算的类。

主要方法：
- `HeatTransfer(params)`: 构造函数
- `calculateConvection(T_particle, T_ambient, diameter)`: 计算对流换热
- `calculateRadiation(T_particle, T_ambient, diameter)`: 计算辐射换热
- `calculateTotalHeatTransfer(T_particle, T_ambient, diameter)`: 计算总热传递

### 5. 预热阶段求解器 (`PreheatingStage.m`)

处理颗粒从初始温度到熔点的加热过程。

主要方法：
- `PreheatingStage(model, params)`: 构造函数
- `solve(tspan)`: 求解预热阶段
- `odefun(t, y)`: ODE函数，定义温度变化率
- `events(t, y)`: 事件函数，当温度达到熔点时终止

### 6. 熔融阶段求解器 (`MeltingStage.m`)

处理颗粒在熔点温度下的熔融过程。

主要方法：
- `MeltingStage(model, params)`: 构造函数
- `solve(tspan)`: 求解熔融阶段
- `odefun(t, y)`: ODE函数，定义熔融分数变化率
- `events(t, y)`: 事件函数，当熔融分数达到1时终止

### 7. 熔融后加热阶段求解器 (`HeatingStage.m`)

处理颗粒从熔点到点火温度的加热过程。

主要方法：
- `HeatingStage(model, params)`: 构造函数
- `solve(tspan)`: 求解熔融后加热阶段
- `odefun(t, y)`: ODE函数，定义温度变化率
- `events(t, y)`: 事件函数，当温度达到点火温度时终止

### 8. 气相燃烧阶段求解器框架 (`VaporizationStage.m`)

处理颗粒在点火温度下的气相燃烧过程（框架代码，留待后续实现）。

主要方法：
- `VaporizationStage(model, params)`: 构造函数
- `solve(tspan)`: 求解气相燃烧阶段（框架）
- `odefun(t, y)`: ODE函数（待实现）
- `calculateReactionRate(T, ambient_composition)`: 计算反应速率（待实现）
- `calculateHeatRelease(reaction_rate)`: 计算反应放热（待实现）

### 9. 阶段管理器 (`StageManager.m`)

管理不同阶段的切换和求解。

主要属性：
- 颗粒模型
- 参数对象
- 各阶段求解器
- 结果存储（时间历史、温度历史、熔融分数历史、阶段历史）

主要方法：
- `StageManager(model, params)`: 构造函数
- `solve()`: 求解整个过程
- `recordResults(t, T, X_melt, stage_name)`: 记录结果

### 10. 结果可视化 (`Visualization.m`)

提供各种可视化方法。

主要方法：
- `plotResults(results)`: 绘制结果
- `saveResults(results, filename)`: 保存结果到文件
- `exportToCSV(results, filename)`: 导出结果到CSV文件

## 模拟流程

1. 初始化参数和模型
2. 确定初始阶段（通常是预热阶段）
3. 使用对应的阶段求解器求解
4. 检测阶段转换事件
5. 切换到下一个阶段
6. 重复步骤3-5，直到完成所有阶段或达到总仿真时间
7. 输出和可视化结果

## 物理模型

### 预热阶段

微分方程：
```
dT/dt = (Q_conv + Q_rad) / (m * Cp)
```
其中：
- Q_conv：对流换热
- Q_rad：辐射换热
- m：颗粒质量
- Cp：比热容

### 熔融阶段

微分方程：
```
dX_melt/dt = (Q_conv + Q_rad) / (m * L_fusion)
```
其中：
- X_melt：熔融分数（0-1）
- L_fusion：熔化潜热

### 熔融后加热阶段

微分方程：
```
dT/dt = (Q_conv + Q_rad) / (m * Cp)
```

### 气相燃烧阶段

待实现

## 使用方法

1. 在MATLAB环境中运行`main.m`
2. 结果将自动保存到`results`目录
3. 可视化结果将显示在图形窗口中

## 扩展方向

1. 完善气相燃烧阶段的实现
2. 添加更复杂的反应动力学模型
3. 考虑颗粒尺寸变化
4. 添加更多的环境参数影响
5. 实现三维可视化 

## 附录：MATLAB bvp4c 求解器调试历程

在本次对镁颗粒燃烧模型的仿真开发过程中，我们遇到了MATLAB的边界值问题求解器 `bvp4c` 的一系列深层问题。本附录旨在记录整个调试过程，为未来处理类似复杂BVP问题提供经验和参考。

### 第一阶段：`bvpinit` 的参数传递陷阱

- **问题**: 在尝试向 `bvpinit` 的初始猜测函数传递额外参数（如物理常数）时，遭遇 `未定义与 'struct' 类型的输入参数相对应的函数 'eq'` 错误。
- **根源分析**: `bvpinit` 的可变参数 (`varargin`) 机制会改变其对猜测函数的调用方式。它不会像 `bvp4c` 的主函数那样在末尾追加参数，而是用我们提供的参数结构体替换掉了原本应该传递的 `region` 索引，导致了函数签名不匹配和类型错误。
- **解决方案**: 放弃使用 `bvpinit` 的参数传递功能，转而手动构建 `solinit` 结构体，或使用不依赖额外参数的猜测函数。这揭示了 `bvpinit` 和 `bvp4c` 在处理函数句柄参数方面存在微妙但不兼容的差异。

### 第二阶段：函数句柄的“上下文丢失”问题

- **问题**: 即使绕过了 `bvpinit` 的问题，在 `bvp4c` 的主调用中仍然反复出现 `输入参数的数目不足` 的错误。
- **根源分析**: 经过多次尝试（包括匿名函数闭包、类方法句柄、嵌套函数），我们最终确定，在 `ode45` -> `StageManager` -> `VaporizationStage` 这种深层、复杂的调用链中，MATLAB的底层机制（很可能是C++内核通过 `feval` 回调）**无法正确保留和传递函数句柄所需的上下文（context）**。无论是匿名函数的闭包变量，还是嵌套函数所依赖的父函数工作区，都在这个过程中丢失了。
- **最终解决方案**: 使用**全局变量**。这是在MATLAB中唯一能够穿越任何调用层级和隔离工作区的机制。我们将所有依赖项（物理参数、当前颗粒状态等）打包放入一个全局结构体，在调用 `bvp4c` 前设置它，在`ode_func`和`bc_func`内部访问它，并在求解结束后立即清理该全局变量。这被证明是解决上下文传递问题的最可靠、最根本的方法。

### 第三阶段：多点BVP的“配置协议”问题

在解决了上下文传递之后，我们遭遇了一系列与 `bvp4c` 如何理解和配置一个**多点边界值问题 (Multi-point BVP)** 相关的错误。

1.  **`solinit.parameters` 字段的缺失**:
    - **问题**: `输入参数的数目不足`，错误指向 `ode_func`。
    - **分析**: `bvp4c`通过检查 `solinit` 结构体中是否存在 `.parameters` 字段来判断问题是否包含未知参数。如果该字段不存在，`bvp4c` 会用不含参数 `p` 的签名去调用 `ode_func`，导致错误。
    - **解决**: 手动构建 `solinit` 时，必须明确地创建 `.parameters` 字段并填入参数的初始猜测值。

2.  **`xinit` 网格的构建**:
    - **问题**: 在`ode_func`签名需要`region`参数和`bc_func`使用矩阵索引的情况下，仍然出现签名不匹配或索引错误。
    - **分析**: `bvp4c`通过**初始网格 `xinit` 中是否存在重复的点**来判断这是一个两点BVP还是多点BVP。使用 `unique(xinit)` 会将网格“压平”，使 `bvp4c` 误认为这是一个两点问题，从而不传递 `region` 索引，并期望 `bc_func` 接收向量而非矩阵。
    - **解决**: 对于多区域问题，必须在 `xinit` 中保留重复的接口点（如 `[... r_f, r_f, ...]`），并且**绝对不能**使用 `unique()`。

3.  **`bc_func` 的索引语法**:
    - **问题**: `此类型的变量不支持使用花括号进行索引。`
    - **分析**: 当 `bvp4c` 以多点模式运行时，它向 `bc_func` 传递的边界值 `yl` 和 `yr` 是**数值矩阵**，其中 `yl(:,k)` 代表第`k`个区域的左边界值。花括号 `{}` 是元胞数组的语法。
    - **解决**: 必须使用标准的矩阵列索引 `()`，如 `yl(:,1)`。

4.  **`bc_func` 返回向量的长度**:
    - **问题**: `边界条件函数 BCFUN 应返回一个长度为 22 的列向量。`
    - **分析**: `bvp4c` 根据 `期望长度 = (状态变量数 * 区域数) + 未知参数数` 的公式计算出数学上封闭系统所必需的条件数量。我们的模型（10个状态变量，2个区域，2个未知参数）需要 `10*2 + 2 = 22` 个条件。
    - **解决**: 通过对物理模型的严谨分析，我们最终构建了一个包含9个外边界条件和13个火焰面接口条件（包括连续性、反应物耗尽、单边导数约束、能量跳变和化学计量关系）的完整体系，满足了数学完备性的要求。

通过解决以上所有问题，我们最终构建了一个在结构上与`bvp4c`求解器完全兼容、在物理和数学上自洽的BVP模型。这个调试过程深刻地揭示了在使用高级数值求解器时，不仅需要理解物理模型，更需要精确地遵循求解器内部的工作机制和“配置协议”。 
